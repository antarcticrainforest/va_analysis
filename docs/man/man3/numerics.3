.TH "numerics" 3 "Fri Apr 27 2018" "Variational Analysis" \" -*- nroff -*-
.ad l
.nh
.SH NAME
numerics \- 
.SH SYNOPSIS
.br
.PP
.SS "Functions/Subroutines"

.in +1c
.ti -1c
.RI "subroutine \fBitps\fP (KS, KB, D, DS)"
.br
.ti -1c
.RI "subroutine \fBgmean\fP (MG, DP, NV, NST, NT, TSMOOTH)"
.br
.ti -1c
.RI "subroutine \fBsmooth\fP (ARRAY, N, FILTER_WIDTH, CYCLIC)"
.br
.ti -1c
.RI "subroutine \fBcaldev\fP (DU, KT, KS, NSTU, NTU, NP, NVU, DEVM2)"
.br
.ti -1c
.RI "subroutine \fBhorizontal_field\fP (NST, LON, LAT, X, Y, F, DZDX, DZDY, DIVU, DIVV)"
.br
.ti -1c
.RI "subroutine \fBline_fit_xyz\fP (N, X, Y, Z, DZDX, DZDY, Z0)"
.br
.ti -1c
.RI "subroutine \fBwindown\fP (N, X, DX, X1, L0, L1)"
.br
.ti -1c
.RI "subroutine \fBassim\fP (NP, DP, P, KS, KB, KT, NSTU, LONU, LATU, DU, NSTS, LONS, LATS, DSS, DIVBVAR, FCX, FCY, FPX, FPY, BUDGET, NADVAR, WVAR, DUS)"
.br
.ti -1c
.RI "subroutine \fBcalc_budget_layer\fP (NP, NTU, P, BUDGET_LAYER, BUDGET_COLUMNS, AVE_QS, AVE_SS)"
.br
.in -1c
.SH "Function/Subroutine Documentation"
.PP 
.SS "subroutine numerics::assim (integer (kind=ik4), intent(in) NP, real (kind=rk8), intent(in) DP, real (kind=rk8), dimension(np), intent(in) P, integer (kind=ik4), intent(in) KS, integer (kind=ik4), intent(in) KB, integer (kind=ik4), intent(in) KT, integer (kind=ik4), intent(in) NSTU, real (kind=rk8), dimension(nstu), intent(in) LONU, real (kind=rk8), dimension(nstu), intent(in) LATU, real (kind=rk8), dimension(nvu,np,nstu), intent(inout) DU, integer (kind=ik4), intent(in) NSTS, real (kind=rk8), dimension(nsts), intent(in) LONS, real (kind=rk8), dimension(nsts), intent(in) LATS, real (kind=rk8), dimension(nvs, nsts), intent(inout) DSS, real (kind=rk8), dimension(nvbudget_layer,np), intent(out) DIVBVAR, real (kind=rk8), dimension(np), intent(out) FCX, real (kind=rk8), dimension(np), intent(out) FCY, real (kind=rk8), dimension(np), intent(out) FPX, real (kind=rk8), dimension(np), intent(out) FPY, real (kind=rk8), dimension(nvbudget_column, ntermmax), intent(inout) BUDGET, integer (kind=ik4), intent(in) NADVAR, real (kind=rk8), dimension(5,np, nstu), intent(inout) WVAR, real (kind=rk8), dimension(nvu,np,nstu), intent(out) DUS)"

.PP
Definition at line 429 of file numerics\&.f90\&.
.PP
.nf
429 USE portable
430 USE constants
431 USE settings
432 USE lu
433 USE physics
434 
435 IMPLICIT NONE
436 
437 INTEGER (KIND=IK4), INTENT(IN)                                      :: np       ! Number of pressure levels\&.
438 REAL (KIND=RK8), INTENT(IN)                                         :: dp       ! Spacing of the pressure levels (Pa)\&.
439 REAL (KIND=RK8), DIMENSION(NP), INTENT(IN)                          :: p        ! Pressure of each level (hPa)
440 INTEGER (KIND=IK4), INTENT(IN)                                      :: ks       ! Index of level where the surface pressure is\&.
441 INTEGER (KIND=IK4), INTENT(IN)                                      :: kb       ! Index of level where the surface is\&.
442 INTEGER (KIND=IK4), INTENT(IN)                                      :: kt       ! Index of the top level\&.
443 INTEGER (KIND=IK4), INTENT(IN)                                      :: nstu     ! Number of upper air stations\&.
444 REAL (KIND=RK8), DIMENSION(NSTU), INTENT(IN)                        :: lonu     ! Longitudes of the upper air stations
445 REAL (KIND=RK8), DIMENSION(NSTU), INTENT(IN)                        :: latu     ! Latitudes of the upper air stations
446 REAL (KIND=RK8), DIMENSION(NVU,NP,NSTU), INTENT(INOUT)              :: du       ! Array containing all the upper level data\&.
447                                                                                 ! DU(1,:,:)   = 1\&.0
448                                                                                 ! DU(2,:,:)   = rLv0/cpd
449                                                                                 ! DU(3,:,:)   = dry static energy
450                                                                                 ! DU(4,:,:)   = u
451                                                                                 ! DU(5,:,:)   = v
452                                                                                 ! DU(6,:,:)   = T
453                                                                                 ! DU(7,:,:)   = z
454                                                                                 ! DU(8,:,:)   = P
455                                                                                 ! DU(9,:,:)   = lon
456                                                                                 ! DU(10,:,:)  = lat
457 INTEGER (KIND=IK4), INTENT(IN)                                      :: nsts     ! Number of surface level stations
458 REAL (KIND=RK8), DIMENSION(NSTS), INTENT(IN)                        :: lons     ! Longitudes of the surface stations\&.
459 REAL (KIND=RK8), DIMENSION(NSTS), INTENT(IN)                        :: lats     ! Latitudes of the surface stations\&.
460 REAL (KIND=RK8), DIMENSION(NVS, NSTS), INTENT(INOUT)                :: dss      ! Array containing all the surface level data\&.
461 REAL (KIND=RK8), DIMENSION(NVBUDGET_LAYER,NP), INTENT(OUT)          :: divbvar  !
462 REAL (KIND=RK8), DIMENSION(NP), INTENT(OUT)                         :: fcx      !
463 REAL (KIND=RK8), DIMENSION(NP), INTENT(OUT)                         :: fcy      !
464 REAL (KIND=RK8), DIMENSION(NP), INTENT(OUT)                         :: fpx      !
465 REAL (KIND=RK8), DIMENSION(NP), INTENT(OUT)                         :: fpy      !
466 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN, NTERMMAX), INTENT(INOUT):: budget   !
467 INTEGER (KIND=IK4), INTENT(IN)                                      :: nadvar   !
468 REAL (KIND=RK8), DIMENSION(5,NP, NSTU), INTENT(INOUT)               :: wvar     !
469 REAL (KIND=RK8), DIMENSION(NVU,NP,NSTU), INTENT(OUT)                :: dus      !
470 
471 !
472 ! Local variables\&.
473 !
474 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: f                ! Coriolis parameter at each station and level\&.
475 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: dzdx             ! 
476 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: dzdy             !
477 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: divu             !
478 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: divv             !
479 
480 REAL (KIND=RK8), DIMENSION(NSTU)                    :: x                ! Cartesian x-coords of the stations at a single level\&.
481 REAL (KIND=RK8), DIMENSION(NSTU)                    :: y                ! Cartesian y-coords of the stations at a single level\&.
482 REAL (KIND=RK8), DIMENSION(NSTS)                    :: xs               ! Cartesian x-coords of the surface stations\&.
483 REAL (KIND=RK8), DIMENSION(NSTS)                    :: ys               ! Cartesian y-coords of the surface stations\&.
484 REAL (KIND=RK8), DIMENSION(1,NSTS)                  :: fs               ! Coriolis parameters of the surface stations\&.
485 REAL (KIND=RK8), DIMENSION(1,NSTS)                  :: dzdxs            ! DZDX of the surface stations\&.
486 REAL (KIND=RK8), DIMENSION(1,NSTS)                  :: dzdys            ! DZDY of the surface stations\&.
487 REAL (KIND=RK8), DIMENSION(1,NSTS)                  :: divus            ! DIVU of the surface stations\&.
488 REAL (KIND=RK8), DIMENSION(1,NSTS)                  :: divvs            ! DIVV of the surface stations\&.
489 
490 INTEGER (KIND=IK4)                                  :: kk, mm, ist, mb, mb1, mvar, mad   ! Counters\&.
491 REAL (KIND=RK8)                                     :: two      = 2\&.0
492 REAL(KIND=RK8), DIMENSION(5)                        :: ad       = 1\&.0   !
493 INTEGER (KIND=IK4)                                  :: nterm            !
494 
495 ! The IDL code is messy \&.\&.\&. these were all declared for the first time in the middle of other stuff\&.
496 ! For safety, we initialise many of the variables to 0 (unless the IDL code specifies otherwise)\&. Actually, if you look at
497 ! the accompanying make files, you'll see I use a g95 option for initially zeroing variables when they are declared\&.
498 
499 REAL (KIND=RK8), DIMENSION(NSTU)                    :: unith
500 REAL (KIND=RK8), DIMENSION(NSTS)                    :: uniths
501 REAL (KIND=RK8), DIMENSION(NP)                      :: unitv
502 REAL (KIND=RK8), DIMENSION(NP)                      :: unitv1
503 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN)         :: c
504 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN)         :: b
505 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN, NVBUDGET_COLUMN, NP, NSTU)    :: dbdvar   ! Important one\&.
506 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN, NVBUDGET_COLUMN)              :: a
507 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN)                               :: ld
508 
509 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: bvar
510 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: unitvar                      ! This is called UNIT in the IDL code\&.
511 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: u
512 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: v
513 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: r
514 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: h
515 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: z 
516 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: t
517 
518 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: bvar1
519 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: u1
520 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: v1
521 REAL (KIND=RK8), DIMENSION(NP)                      :: r2
522 REAL (KIND=RK8), DIMENSION(NP)                      :: h2
523 REAL (KIND=RK8), DIMENSION(NP)                      :: z2
524 REAL (KIND=RK8), DIMENSION(NP, NSTU)                :: z1
525 
526 REAL (KIND=RK8), DIMENSION(1, NSTS)                 :: bvars
527 REAL (KIND=RK8), DIMENSION(1, NSTS)                 :: us
528 REAL (KIND=RK8), DIMENSION(1, NSTS)                 :: vs
529 REAL (KIND=RK8), DIMENSION(1, NSTS)                 :: zs
530 REAL (KIND=RK8), DIMENSION(1, NSTS)                 :: ts
531 INTEGER (KIND=IK4), DIMENSION(4)                    :: madn = (/ 4, 5, 2, 3 /) 
532 
533 REAL (KIND=RK8), DIMENSION(NAD, NAD)                :: a1
534 !REAL (KIND=RK8), DIMENSION(NAD, NAD)                :: A2
535 REAL (KIND=RK8), DIMENSION(NAD)                     :: b1, ld1
536 REAL (KIND=RK8), DIMENSION(NP)                      :: div1, div2               ! Divergences, for NP levels\&.
537 REAL (KIND=RK8), DIMENSION(1)                       :: divs                     ! Divergence for a single level\&.
538 REAL (KIND=RK8), DIMENSION(NP)                      :: fcx1, fpx1, fcy1, fpy1
539 REAL (KIND=RK8), DIMENSION(1)                       :: fcxs, fcys, fpxs, fpys
540 INTEGER (KIND=IK4)                                  :: d, code
541 INTEGER (KIND=IK4), DIMENSION(NAD)                  :: indx
542 REAL (KIND=RK8), DIMENSION(NP)                      :: sc, rc
543 REAL (KIND=RK8), DIMENSION(NP,NSTU)                      :: old1, old2,test1,test2               ! Divergences, for NP levels\&.
544 
545 !
546 ! What a lot of stuff that was \&.\&.\&. surely it can be reduced!
547 !
548 ! Initialise a whole lot of variables\&. For safety, we initialise lots of things with 0\&.0 (unless the IDL code specified otherwise)\&.
549 ! This is because Fortran does not guarantee that variables will be initialised to any particular value when they are declared\&.
550 !
551 f       = 0\&.0
552 dzdx    = 0\&.0   
553 dzdy    = 0\&.0
554 divu    = 0\&.0
555 divv    = 0\&.0
556 x       = 0\&.0
557 y       = 0\&.0
558 xs      = 0\&.0
559 ys      = 0\&.0
560 fs      = 0\&.0
561 dzdxs   = 0\&.0
562 dzdys   = 0\&.0
563 divus   = 0\&.0
564 divvs   = 0\&.0
565 unith   = 1\&.0
566 uniths  = 1\&.0
567 unitv   = 0\&.0
568 unitv1  = 0\&.0
569 c       = 0\&.0
570 b       = 0\&.0
571 dbdvar  = 0\&.0
572 a       = 0\&.0
573 ld      = 0\&.0
574 bvar    = 0\&.0
575 unitvar = 0\&.0
576 u       = 0\&.0
577 v       = 0\&.0
578 r       = 0\&.0
579 h       = 0\&.0
580 z       = 0\&.0
581 t       = 0\&.0
582 bvar1   = 0\&.0
583 u1      = 0\&.0
584 v1      = 0\&.0
585 r2      = 0\&.0
586 h2      = 0\&.0
587 z2      = 0\&.0
588 z1      = 0\&.0
589 bvars   = 0\&.0
590 us      = 0\&.0
591 vs      = 0\&.0
592 zs      = 0\&.0
593 ts      = 0\&.0
594 a1      = 0\&.0
595 !A2      = 0\&.0
596 b1      = 0\&.0
597 ld1     = 0\&.0
598 div1    = 0\&.0
599 div2    = 0\&.0
600 divs    = 0\&.0
601 fcx1    = 0\&.0
602 fpx1    = 0\&.0
603 fcy1    = 0\&.0
604 fpy1    = 0\&.0
605 fcxs    = 0\&.0
606 fcys    = 0\&.0
607 fpxs    = 0\&.0
608 fpys    = 0\&.0
609 d       = 0
610 code    = 0
611 indx    = 0
612 sc      = 0\&.0
613 rc      = 0\&.0
614 old1    = 0\&.0
615 old2    = 0\&.0
616 test1 = 0\&.0
617 test2 = 0\&.0
618 !
619 ! Calculate the components of the horizontal gradient and divergence at each vertical level, and at the surface\&.
620 ! All the temporary arrays used in the IDL procedure have been replaced by Fortran 90 array sections\&. Simplifies
621 ! things a bit\&.
622 !
623 
624 DO kk=kb,kt
625     CALL horizontal_field(nstu, du(9,kk,:), du(10,kk,:), x, y, f(kk,:), dzdx(kk,:), dzdy(kk,:), divu(kk,:), divv(kk,:))
626 END DO
627 
628 CALL horizontal_field(nsts, lons, lats, xs, ys, fs, dzdxs, dzdys, divus, divvs)
629 DO mm=1,5
630     wvar(mm,:,:)=wvar(mm,:,:)/ad(mm)
631 END DO
632 
633 DO mm=1,nvbudget_column
634     du(mm,1:np,1:nstu) = du(mm,1:np,1:nstu)*ad(mm)
635     dss(mm,1:nsts)=dss(mm,1:nsts)*ad(mm)
636     nterm=int(budget(mm,1), kind=ik4)
637     budget(mm,2:nterm+2)=budget(mm,2:nterm+2)*ad(mm)
638 END DO
639 
640 !
641 ! Initialise more variables\&.
642 !
643 dus             = du
644 
645 unitv(kb:kt)    = 1\&.0
646 unitv1(ks:kt)   = 1\&.0
647 unitv1(ks)      = 0\&.5 + (budget(1,7) - p(ks))/dp*100\&.
648 unitv1(kt)      = 0\&.5
649 unitv(kb)       = 0\&.5 + (budget(1,7) - p(kb))/dp*100\&.
650 unitv(kt)       = 0\&.5
651 
652 !
653 ! Print a warning if the surface level is different than the level at which surface pressure is located (they should be
654 ! the same)\&.
655 !
656 IF (kb \&.NE\&. ks) THEN
657     print *,'Warning: KB different from KS\&. Try to make them the same'
658 END IF
659 
660 !
661 ! Do more stuff\&.
662 !
663 DO mb=1,nvbudget_column
664     nterm   = int(budget(mb, 1), 4)
665     c(mb)   = -sum(budget(mb,3:nterm+1))
666 END DO
667 
668 !
669 ! Fill out UNITVAR, R, H, U, V, Z and T from the big DUS array (which was passed into this procedure as DU)
670 !
671 unitvar(kb:kt,:)    = dus(1,kb:kt,:)
672 r(kb:kt,:)          = dus(2,kb:kt,:)
673 h(kb:kt,:)          = dus(3,kb:kt,:)
674 u(kb:kt,:)          = dus(4,kb:kt,:)
675 v(kb:kt,:)          = dus(5,kb:kt,:)
676 z(kb:kt,:)          = dus(7,kb:kt,:)
677 t(kb:kt,:)          = dus(6,kb:kt,:)
678 
679 !
680 ! Fill out US, VS, ZS and TS from the big DSS array\&.
681 !
682 us(1,:)             = dss(4,:)
683 vs(1,:)             = dss(5,:)
684 zs(1,:)             = dss(7,:)
685 ts(1,:)             = dss(6,:)
686 
687 !
688 ! I think this is where the partial derivatives to the five constraint equations (equations (14)-(17) in Zhang and Lin) are
689 ! calculated \&.\&.\&. maybe\&.
690 !
691 DO kk=kb,kt
692     dbdvar(1,1,kk,:)    = unitvar(kk,:)*divu(kk,:)*dp/g
693     dbdvar(1,2,kk,:)    = unitvar(kk,:)*divv(kk,:)*dp/g
694     dbdvar(2,1,kk,:)    = r(kk,:)*divu(kk,:)*dp/g
695     dbdvar(2,2,kk,:)    = r(kk,:)*divv(kk,:)*dp/g
696     dbdvar(2,3,kk,:)    = (u(kk,:)*divu(kk,:) + v(kk,:)*divv(kk,:))*dp/g
697     dbdvar(3,1,kk,:)    = h(kk,:)*divu(kk,:)*dp/g
698     dbdvar(3,2,kk,:)    = h(kk,:)*divv(kk,:)*dp/g
699     dbdvar(3,4,kk,:)    = (u(kk,:)*divu(kk,:) + v(kk,:)*divv(kk,:))*dp/g
700     dbdvar(4,1,kk,:)    = (2\&.0*u(kk,:)*divu(kk,:) + v(kk,:)*divv(kk,:))*dp/g
701     dbdvar(4,2,kk,:)    = (u(kk,:)*divv(kk,:) - f(kk,:)/nstu)*dp/g
702     dbdvar(4,4,kk,:)    = (kt+1-kk)*rd*dp/100\&.0/p(kk)*dzdx(kk,:)*dp/g
703     dbdvar(5,1,kk,:)    = (v(kk,:)*divu(kk,:) + f(kk,:)/nstu)*dp/g
704     dbdvar(5,2,kk,:)    = (u(kk,:)*divu(kk,:) + 2\&.0*v(kk,:)*divv(kk,:))*dp/g
705     dbdvar(5,4,kk,:)    = (kt+1-kk)*rd*dp/100\&.0/p(kk)*dzdy(kk,:)*dp/g
706 END DO
707 
708 DO mb=1,5                   ! This loops over the first five variables in the dus array\&.
709     bvar(kb:kt,:)       = dus(mb,kb:kt,:)
710     bvars(1,:)          = dss(mb,:)
711 
712     DO mb1=1,5
713         DO ist=1,nstu
714             DO kk=kb,kt
715                 u1(kk,ist)  = -dbdvar(mb1,1,kk,ist)/two/wvar(4,kk,ist)
716                 v1(kk,ist)  = -dbdvar(mb1,2,kk,ist)/two/wvar(5,kk,ist)
717                 r2(kk)      = 0\&.0
718                 h2(kk)      = -dbdvar(mb1,4,kk,ist)/two/wvar(3,kk,ist)
719                 test1(kk,ist)=-wvar(4,kk,ist)
720                 test2(kk,ist)=-wvar(5,kk,ist)
721             END DO
722             CALL height(np, kb, kt, p, h2, r2, z2)
723             z1(:,ist)       = z2(:)
724         END DO
725         CALL diverg(unith=unith, var=bvar, u=u1, v=v1, divu=divu, divv=divv, div1=div2)
726         a(mb,mb1)           = dot_product(div2,unitv)*dp/g          ! Equivalent to IDL code: transpose(div2)#unitv*dp/g
727         !
728         ! Print a warning if ABS(MB,MB1) is greater than 100\&.
729         !
730         !IF (ABS(A(MB,MB1)) \&.GT\&. 100) THEN
731             !PRINT *,'Warning: A(MB,MB1) > 100',MB,MB1,A(MB,MB1)!,DIV2,'\&.\&.',UNITV ,'\&.\&.',DP,'\&.\&.',G
732             !  print *, OLD1,'\&.\&.\&.\&.',test1,'#',MB1
733             !  print *, OLD2,'\&.\&.\&.\&.',test2,'#',MB1
734         !else
735         !    print *, U1,'\&.\&.\&.#\&.\&.\&.\&.',V1
736         !END IF
737         old1=test1
738         old2=test2
739         !
740         ! Calculate extra stuff for MB=4
741         !
742         IF (mb \&.EQ\&. 4) THEN
743             CALL fcorlx(unith, nstu, f, v1, fcx1)
744             CALL fpgd(unith, z1, dzdx, fpx1)
745             a(4,mb1)    = a(4,mb1) - dot_product(fcx1,unitv)*dp/g - dot_product(fpx1,unitv)*dp/g
746         END IF
747 
748         !
749         ! Calculate extra stuff for MB=5
750         !
751         IF (mb \&.EQ\&. 5) THEN
752             CALL fcorly(unith, nstu, f, u1, fcy1)
753             CALL fpgd(unith, z1, dzdy, fpy1)
754             a(5,mb1)    = a(5,mb1) - dot_product(fcy1,unitv)*dp/g - dot_product(fpy1,unitv)*dp/g
755         END IF
756     END DO
757 
758     CALL diverg(unith, bvar, u, v, divu, divv, div1)
759     CALL diverg(uniths, bvars, us, vs, divus, divvs, divs)
760     CALL itps(ks, kb, div1, divs(1))
761     divbvar(mb,ks:kt)   = div1(ks:kt)/ad(mb)
762     b(mb)               = dot_product(div1,unitv1)*dp/g + c(mb)
763     nterm               = int(budget(mb, 1), kind=ik4)
764     budget(mb, nterm+2) = -dot_product(div1,unitv1)*dp/g
765 END DO
766 
767 CALL diverg(unith, t, u, v, divu, divv, div1)
768 CALL diverg(uniths, ts, us, vs, divus, divvs, divs)
769 CALL itps(ks, kb, div1, divs(1))
770 divbvar(6,ks:kt)        = div1(ks:kt)
771 
772 DO mvar=1,nadvar
773     mm  = madn(mvar)
774     DO mb1=1,5
775         bvar1(kb:kt,:)  = -dbdvar(mb1,mvar,kb:kt,:)/2\&.0/wvar(mm,kb:kt,:)
776         CALL diverg(unith, bvar1, u, v, divu, divv, div1)
777         a(mm,mb1)       = a(mm,mb1) + dot_product(div1,unitv)*dp/g
778     END DO
779 END DO
780 
781 CALL fcorlx(unith, nstu, f, v, fcx1)
782 CALL fcorlx(uniths, nsts, fs, vs, fcxs)
783 CALL itps(ks, kb, fcx1, fcxs(1))
784 budget(4,6)     = dot_product(fcx1,unitv1)*dp/g
785 
786 CALL fpgd(unith, z, dzdx, fpx1)
787 CALL fpgd(uniths, zs, dzdxs, fpxs)
788 CALL itps(ks, kb, fpx1, fpxs(1))
789 budget(4,7)     = dot_product(fpx1,unitv1)*dp/g
790 b(4)            = b(4) - budget(4,6) - budget(4,7)
791 
792 CALL fcorly(unith, nstu, f, u, fcy1)
793 CALL fcorly(uniths, nsts, fs, us, fcys)
794 CALL itps(ks, kb, fcy1, fcys(1))
795 budget(5,6)     = dot_product(fcy1,unitv1)*dp/g
796 
797 CALL fpgd(unith, z, dzdy, fpy1)
798 CALL fpgd(uniths, zs, dzdys, fpys)
799 CALL itps(ks, kb, fpy1, fpys(1))
800 budget(5,7)     = dot_product(fpy1,unitv1)*dp/g
801 b(5)            = b(5) - budget(5,6) - budget(5,7)
802 
803 fcx             = fcx1
804 fcy             = fcy1
805 fpx             = fpx1
806 fpy             = fpy1
807 
808 budget(1:5,2)   = -b(1:5)
809 b               = -b
810 
811 a1              = 0\&.0
812 b1              = 0\&.0
813 a1(1:nad,1:nad) = a(1:nad,1:nad)
814 b1(1:nad)       = b(1:nad)
815 !A2              = A1
816 
817 IF (nad \&.LT\&. 3 ) THEN
818     ld1(1)  = b1(1)/a1(1,1)
819 ELSE
820     CALL ludcmp(a=a1, n=nad, indx=indx, d=d, code=code)
821     CALL lubksb(a=a1, n=nad, indx=indx, b=b1)
822     ld1     = b1
823 ENDIF
824 
825 ld(1:nad)   = ld1(1:nad)
826 
827 !
828 ! I think this is where equation (24) in Zhang and Lin is implemented\&.
829 !
830 
831 DO mad=1,nadvar
832     mm = madn(mad)
833     DO mb=1,nad
834         if (mm \&.eq\&. 3) then
835         endif
836         dus(mm,kb:kt,1:nstu)    = dus(mm,kb:kt,1:nstu) - ld(mb)*dbdvar(mb,mad,kb:kt,1:nstu)/2\&.0/wvar(mm,kb:kt,1:nstu)
837     END DO
838 END DO
839 
840 !
841 ! Update T and Z based on s and r\&. This comment is copied directly from IDL code\&.
842 !
843 DO ist=1,nstu
844     sc(1:np)    = dus(3,1:np,ist)
845     rc(1:np)    = dus(2,1:np,ist)*cpd/lv0
846     rc(1)       = dss(2,ist)*cpd/lv0
847     sc(1)       = dss(3,ist)
848     CALL s_r_to_t_z(p, dss(8,ist), dss(7,ist), sc, rc, dus(6,1:np,ist), dus(7,1:np,ist))
849 END DO
850 
851 DO mm=1,nvbudget_column
852     dus(mm,1:np,1:nstu)     = dus(mm,1:np,1:nstu)/ad(mm)
853     nterm   = int(budget(mm,1), kind=ik4)
854     budget(mm,2:nterm+2)    = budget(mm,2:nterm+2)/ad(mm)
855 END DO
856 
.fi
.SS "subroutine numerics::calc_budget_layer (integer (kind=ik4), intent(in) NP, integer (kind=ik4), intent(in) NTU, real (kind=rk8), dimension(np), intent(in) P, real (kind=rk8), dimension(nvbudget_layer,ntermmaxv,np,ntu), intent(inout) BUDGET_LAYER, real (kind=rk8), dimension(nvbudget_column,ntermmax,ntu), intent(in) BUDGET_COLUMNS, real (kind=rk8), dimension(ntu), intent(in) AVE_QS, real (kind=rk8), dimension(ntu), intent(in) AVE_SS)"

.PP
Definition at line 869 of file numerics\&.f90\&.
.PP
.nf
869 USE portable
870 USE constants
871 USE settings
872 
873 IMPLICIT NONE
874 
875 INTEGER (KIND=IK4), INTENT(IN)                                              :: np               ! Number of pressure levels\&.
876 INTEGER (KIND=IK4), INTENT(IN)                                              :: ntu              ! Number of times\&.
877 REAL (KIND=RK8), DIMENSION(NP), INTENT(IN)                                  :: p                ! Pressure of each level (hPa)
878 REAL (KIND=RK8), DIMENSION(NTU), INTENT(IN)                                 :: ave_qs
879 REAL (KIND=RK8), DIMENSION(NTU), INTENT(IN)                                 :: ave_ss
880 REAL (KIND=RK8), DIMENSION(NVBUDGET_COLUMN,NTERMMAX,NTU), INTENT(IN)        :: budget_columns
881 REAL (KIND=RK8), DIMENSION(NVBUDGET_LAYER,NTERMMAXV,NP,NTU), INTENT(INOUT)  :: budget_layer
882 
883 !
884 ! Local variables\&.
885 !
886 REAL (KIND=RK8)                                                     :: dp               ! Vertical resolution (hPa)
887 REAL (KIND=RK8)                                                     :: dp2
888 REAL (KIND=RK8), DIMENSION(6,NP+1)                                  :: omega_vb
889 
890 INTEGER (KIND=IK4)                                                  :: ks               ! Index of surface level\&.
891 INTEGER (KIND=IK4)                                                  :: kt               ! Index of top level\&.
892 INTEGER (KIND=IK4)                                                  :: k1, k2
893 INTEGER (KIND=IK4)                                                  :: nterm
894 
895 INTEGER (KIND=IK4)                                                  :: kk,ll,mvb,iterm  ! Counters\&.
896 
897 !
898 ! Calculate vertical resolution\&.
899 !
900 dp  = p(1) - p(2)
901 
902 DO ll=2,ntu-1
903     ks  = int(budget_layer(1,2,1,ll), kind=ik4)
904     kt  = int(budget_layer(1,4,1,ll), kind=ik4)
905 
906     omega_vb = 0\&.0
907     omega_vb(1,ks)  = -budget_columns(1,3,ll)*g/100\&.0                                   ! hPa/s
908 
909     DO kk=ks,kt
910         budget_layer(1,4,kk,ll) = -budget_layer(1,3,kk,ll)                              ! -dw/dp
911         dp2                     = dp
912         IF (kk \&.EQ\&. ks) dp2     = (budget_columns(1,7,ll) - p(ks)) + 0\&.5*dp
913         IF (kk \&.EQ\&. kt) dp2     = 0\&.5*dp
914         omega_vb(1,kk+1)        = omega_vb(1,kk) + budget_layer(1,4,kk,ll)*dp2          ! DP2 vertically integrated not zero\&.
915     END DO
916 
917     DO mvb=2,6
918         DO kk=ks,kt+1
919             k1                  = max(ks, kk-1)
920             k2                  = min(kt,kk)
921             omega_vb(mvb,kk)    = omega_vb(1,kk) * (budget_layer(mvb,1,k1,ll) + budget_layer(mvb,1,k2,ll))*0\&.5
922         END DO
923     END DO
924 
925     kk                  = ks
926     mvb                 = 2
927     omega_vb(mvb,kk)    = omega_vb(1,kk)*ave_qs(ll)
928     mvb                 = 3
929     omega_vb(mvb,kk)    = omega_vb(1,kk)*ave_ss(ll)
930 
931     DO mvb=1,6
932         nterm                               = int(budget_layer(mvb,1,1,1), kind=ik4)
933         DO kk=ks,kt
934             budget_layer(mvb,nterm+3,kk,ll) = 0\&.5*(omega_vb(mvb,kk) + omega_vb(mvb,kk+1))
935         END DO
936         budget_layer(mvb,nterm+3,kt,ll)     = omega_vb(mvb,kt+1)
937     END DO
938 
939     !
940     ! Vertical flux advection\&.
941     !
942     DO mvb=1,6
943         nterm                               = int(budget_layer(mvb,1,1,1), kind=ik4)
944         DO kk=ks,kt
945             budget_layer(mvb,4,kk,ll)       = -(omega_vb(mvb,kk) - omega_vb(mvb,kk+1))/dp
946         END DO
947         dp2                                 = 0\&.5*dp
948         budget_layer(mvb,4,kt,ll)           = -(omega_vb(mvb,kt) - omega_vb(mvb,kt+1))/dp2
949         dp2                                 = 0\&.5*dp + (budget_columns(1,7,ll) - p(ks))
950         budget_layer(mvb,4,ks,ll)           = -(omega_vb(mvb,ks) - omega_vb(mvb,ks+1))/dp2
951     END DO
952 
953     !
954     ! True advections\&.
955     !
956     DO mvb=2,6
957         budget_layer(mvb,3,ks:kt,ll)    = budget_layer(mvb,3,ks:kt,ll) - budget_layer(mvb,1,ks:kt,ll)*budget_layer(1,3,ks:kt,ll)
958         budget_layer(mvb,4,ks:kt,ll)    = budget_layer(mvb,4,ks:kt,ll) + budget_layer(mvb,1,ks:kt,ll)*budget_layer(1,3,ks:kt,ll)
959     END DO
960 
961     DO mvb=1,5
962         nterm                               = int(budget_layer(mvb,1,1,1), kind=ik4)
963         DO kk=ks,kt
964             budget_layer(mvb,nterm+2,kk,ll) = 0\&.0
965             DO iterm=2,nterm+1
966                 budget_layer(mvb,nterm+2,kk,ll) = budget_layer(mvb,nterm+2,kk,ll) - budget_layer(mvb,iterm,kk,ll)
967             END DO
968         END DO
969     END DO
970 
971     DO kk=ks,kt
972         budget_layer(2,8,kk,ll) = budget_layer(2,3,kk,ll) + budget_layer(2,4,kk,ll)
973         budget_layer(3,8,kk,ll) = budget_layer(3,3,kk,ll) + budget_layer(3,4,kk,ll)
974         budget_layer(2,7,kk,ll) = budget_layer(3,5,kk,ll) + budget_layer(2,5,kk,ll) - budget_layer(3,7,kk,ll)
975     END DO
976 END DO
977 
.fi
.SS "subroutine numerics::caldev (real (kind=rk8), dimension(nvu,np,nstu,ntu), intent(in) DU, integer (kind=ik4), intent(in) KT, integer (kind=ik4), intent(in) KS, integer (kind=ik4), intent(in) NSTU, integer (kind=ik4), intent(in) NTU, integer (kind=ik4), intent(in) NP, integer (kind=ik4), intent(in) NVU, real (kind=rk8), dimension(nvu,np) DEVM2)"

.PP
Definition at line 172 of file numerics\&.f90\&.
.PP
.nf
172 USE portable
173 USE constants
174 
175 INTEGER (KIND=IK4), INTENT(IN)                          :: kt       ! Top level for the variational analysis\&.
176 INTEGER (KIND=IK4), INTENT(IN)                          :: ks       ! Surface level for the variational analysis\&.
177 INTEGER (KIND=IK4), INTENT(IN)                          :: nstu     ! Number of stations\&.
178 INTEGER (KIND=IK4), INTENT(IN)                          :: ntu      ! Number of times\&.
179 INTEGER (KIND=IK4), INTENT(IN)                          :: np       ! Number of pressure levels\&.
180 INTEGER (KIND=IK4), INTENT(IN)                          :: nvu      ! Number of variables\&.
181 REAL (KIND=RK8), DIMENSION(NVU,NP,NSTU,NTU), INTENT(IN) :: du       ! Holds the data (see assim\&.f90 for a description of the array)
182 REAL (KIND=RK8), DIMENSION(NVU,NP)                      :: devm2    ! Holds the RMSE and other stuff\&.
183 
184 !
185 ! Local variables\&.
186 !
187 REAL (KIND=RK8), DIMENSION(NVU,NP)                      :: devm     ! Holds the time mnd station ean of the variables\&.
188 REAL (KIND=RK8), DIMENSION(NVU,NP,NSTU,NTU)             :: dev      ! The difference between the variables and the mean (DEVM)
189 
190 INTEGER (KIND=IK4)                                      :: ii, ist  !  Counters
191 
192 !
193 ! Here we calculate the mean of the five variables accross the stations at each level\&. When calculating the mean, neglect the
194 ! start and end times\&.
195 !
196 devm(2:6,ks:kt) = sum(sum(du(2:6,ks:kt,:,2:ntu-1),dim=4),dim=3)/nstu/(ntu-2)
197 
198 !
199 ! Now calculate the difference from the mean\&. This is easiest to do in a traditional loop\&.
200 !
201 dev                 = 0\&.0
202 DO ii=2,ntu-1
203     DO ist=1,nstu
204         dev(:,:,ist,ii) = du(:,:,ist,ii) - devm(:,:)
205     END DO
206 END DO
207 
208 !
209 ! Finally, calculate the RMSE\&.
210 devm2               = devm
211 devm2(2:6,ks:kt)    = sqrt(sum(sum(dev(2:6,ks:kt,:,2:ntu-1)**2,dim=4),dim=3)/nstu/(ntu-2))
212 
213 devm2(2,:)          = devm2(2,:)/lv0*cpd    ! The other stuff mentioned above\&.
214 
.fi
.SS "subroutine numerics::gmean (real (kind=rk8), dimension(nt), intent(out) MG, real (kind=rk8), dimension(nv,nst,nt), intent(in) DP, integer (kind=ik4), intent(in) NV, integer (kind=ik4), intent(in) NST, integer (kind=ik4), intent(in) NT, integer (kind=ik4), intent(in) TSMOOTH)"

.PP
Definition at line 61 of file numerics\&.f90\&.
.PP
.nf
61 USE portable
62 
63 IMPLICIT NONE
64 INTEGER (KIND=IK4), INTENT(IN)                      :: nt           ! Number of time steps\&.
65 INTEGER (KIND=IK4), INTENT(IN)                      :: tsmooth      ! 0 = no smoothing\&.
66 INTEGER (KIND=IK4), INTENT(IN)                      :: nv           ! Number of variables (only the last variable is averaged)\&.
67 INTEGER (KIND=IK4), INTENT(IN)                      :: nst          ! Number of stations in the analysis grid\&.
68 REAL (KIND=RK8), DIMENSION(NT), INTENT(OUT)         :: mg           ! The spatial average of DP is stored in this array\&.
69 REAL (KIND=RK8), DIMENSION(NV,NST,NT), INTENT(IN)   :: dp           ! Data to be averaged, and possibly time smoothed\&.
70 
71 mg  = sum(dp(nv,:,:), dim=1)/nst        ! Average the last variable along the station dimension (DIM=1, because the rank of the
72                                         ! array subsection is only two (the variable dimension "collapses" when the subsection
73                                         ! is extracted))\&.
74 IF (tsmooth \&.GT\&. 0) THEN
75     CALL smooth(mg, SIZE(mg), tsmooth, \&.false\&.)
76 END IF
77 
.fi
.SS "subroutine numerics::horizontal_field (integer (kind=ik4), intent(in) NST, real (kind=rk8), dimension(nst), intent(in) LON, real (kind=rk8), dimension(nst), intent(in) LAT, real (kind=rk8), dimension(nst), intent(out) X, real (kind=rk8), dimension(nst), intent(out) Y, real (kind=rk8), dimension(nst), intent(out) F, real (kind=rk8), dimension(nst), intent(out) DZDX, real (kind=rk8), dimension(nst), intent(out) DZDY, real (kind=rk8), dimension(nst), intent(out) DIVU, real (kind=rk8), dimension(nst), intent(out) DIVV)"

.PP
Definition at line 231 of file numerics\&.f90\&.
.PP
.nf
231 USE constants
232 
233 IMPLICIT NONE
234 INTEGER (KIND=IK4), INTENT(IN)                :: nst          ! The number of stations in the array\&.
235 REAL (KIND=RK8), DIMENSION(NST), INTENT(IN)   :: lon          ! The longitudes of each station\&.
236 REAL (KIND=RK8), DIMENSION(NST), INTENT(IN)   :: lat          ! The latitudes of each station\&.
237 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: x            ! The cartesian x-coordinates of each station\&.
238 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: y            ! The cartesian y-coordinates of each station\&.
239 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: f            ! Coriolis parameter at each station\&.
240 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: dzdx         !
241 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: dzdy         !
242 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: divu         !
243 REAL (KIND=RK8), DIMENSION(NST), INTENT(OUT)  :: divv         !
244 
245 !
246 ! Local variables\&.
247 !
248 REAL (KIND=RK8), DIMENSION(NST)               :: z1
249 REAL (KIND=RK8), DIMENSION(NST+2)             :: x1, y1               ! Holds coordinates of next station in the "loop"\&.
250 INTEGER (KIND=IK4)                            :: ii                   ! Counter\&.
251 REAL (KIND=RK8)                               :: ax, ay, bx, by, c3   ! Temporary variables\&.
252 REAL (KIND=RK8)                               :: area                 ! Area of sounding array\&.
253 
254 !
255 ! Calculate the cartesian co-ordinates of each station, and the coriolis parameter at each station\&.
256 !
257 
258 x   = 2\&.0*sin((lon-lon(1))/360\&.0*2*pi/2\&.0)*rearth*cos(lat/180\&.0*pi)
259 y   = 2\&.0*sin((lat-lat(1))/360\&.0*2*pi/2\&.0)*rearth
260 f   = 2\&.0*omega*sin(lat/180\&.0*pi)
261 
262 !
263 ! Calculate the gradient terms\&. We do this by fitting a plane of best fit to the points\&.
264 !
265 z1  = 0
266 DO ii=1,nst
267     z1(ii)   = 1\&.0
268     CALL line_fit_xyz(nst, x, y, z1, dzdx(ii), dzdy(ii), c3)
269     z1(ii)   = 0\&.0
270 END DO
271 
272 !
273 ! Set X1 and Y1 to contain the coordinates of the next station in the "loop"
274 !
275 DO ii=1,nst
276     x1(ii+1)    = x(ii)
277     y1(ii+1)    = y(ii)
278 END DO
279 x1(1)       = x1(nst+1)
280 y1(1)       = y1(nst+1)
281 x1(nst+2)   = x1(2)
282 y1(nst+2)   = y1(2)
283 
284 !
285 ! Calculate the area of the sounding array\&.
286 !
287 area        = 0\&.0
288 DO ii=2,nst-1
289     ax      = x(1) - x(ii)
290     ay      = y(1) - y(ii)
291     bx      = x(1) - x(ii+1)
292     by      = y(1) - y(ii+1)
293     area    = area + abs(ax*by - ay*bx)/2\&.0
294 END DO
295 
296 !
297 ! Now calculate the divergence terms using the line integral method (see Davies-Jones (1993) equations 8-10)
298 !
299 DO ii=1,nst
300     divu(ii)    = (y1(ii+2) - y1(ii))/2\&.0/area
301     divv(ii)    = -(x1(ii+2) - x1(ii))/2\&.0/area
302 END DO
303 
.fi
.SS "subroutine numerics::itps (integer (kind=ik4), intent(in) KS, integer (kind=ik4), intent(in) KB, real (kind=rk8), dimension(:), intent(inout) D, real (kind=rk8), intent(in) DS)"

.PP
Definition at line 23 of file numerics\&.f90\&.
.PP
.nf
23 USE portable
24 
25 IMPLICIT NONE
26 
27 INTEGER (KIND=IK4), INTENT(IN)              :: ks   ! Level where the surface pressure is\&.
28 INTEGER (KIND=IK4), INTENT(IN)              :: kb   ! Level where the actual surface is\&.
29 REAL (KIND=RK8), DIMENSION(:),INTENT(INOUT) :: d    ! Array to hold interpolated data\&.
30 REAL (KIND=RK8), INTENT(IN)                 :: ds   ! Value of D at the level where the surface pressure is\&.
31 
32 !
33 ! Local variables\&.
34 !
35 INTEGER (KIND=IK4)                          :: kk   ! Counter\&.
36 
37 IF (ks \&.LT\&. kb) THEN
38     !
39     ! If we enter this loop, the surface pressure level is lower than the level where the surface is\&. No other case
40     ! (apart from the ideal one, where the surface pressure and surface levels are the same) is considered\&.
41     !
42     d(ks)       = ds
43     DO kk=ks+1,kb-1
44         d(kk)   = ds + (d(kb) - ds)/(kb - ks)*(kk - ks)
45     END DO
46 END IF
47 
.fi
.SS "subroutine numerics::line_fit_xyz (integer (kind=ik4), intent(in) N, real (kind=rk8), dimension(n), intent(in) X, real (kind=rk8), dimension(n), intent(in) Y, real (kind=rk8), dimension(n), intent(in) Z, real (kind=rk8), intent(out) DZDX, real (kind=rk8), intent(out) DZDY, real (kind=rk8), intent(out) Z0)"

.PP
Definition at line 318 of file numerics\&.f90\&.
.PP
.nf
318 USE portable
319 USE lu
320 
321 IMPLICIT NONE
322 
323 INTEGER (KIND=IK4), INTENT(IN)              :: n            ! The number of points
324 REAL (KIND=RK8), DIMENSION(N), INTENT(IN)   :: x            ! The cartesian x-coordinates of each point
325 REAL (KIND=RK8), DIMENSION(N), INTENT(IN)   :: y            ! The cartesian y-coordinates of each point
326 REAL (KIND=RK8), DIMENSION(N), INTENT(IN)   :: z            ! The z-value at each point
327 REAL (KIND=RK8), INTENT(OUT)                :: dzdx         ! Slope of the plane in the x-direction
328 REAL (KIND=RK8), INTENT(OUT)                :: dzdy         ! Slope of the plane in the y-direction
329 REAL (KIND=RK8), INTENT(OUT)                :: z0           ! z-value at (x,y) = (0,0)
330 
331 !
332 ! Local variables\&.
333 !
334 REAL (KIND=RK8), DIMENSION(3,3)             :: a 
335 REAL (KIND=RK8), DIMENSION(3)               :: b
336 INTEGER (KIND=IK4), DIMENSION(3)            :: indx
337 INTEGER (KIND=IK4)                          :: code, d
338 
339 !
340 ! By solving the equation    | sum(x^2)  sum(xy)     sum(x)  |     | sum(xz) |
341 !                            | sum(xy)   sum(y^2)    sum(y)  | X = | sum(yz) |
342 !                            | sum(x)    sum(y)      N       |     | sum(z)  |
343 !
344 ! for X, we can find the slopes DZDX, DZDY aand the intercept Z0 (all defined above) for the plane of best fit:
345 !
346 !     | DZDX |
347 ! X = | DZDY |
348 !     |  Z0  |
349 !
350 ! Whoever worked this out was pretty clever\&.
351 !
352 
353 a = reshape(source=(/   sum(x*x), sum(x*y), sum(x), &
354 &                       sum(x*y), sum(y*y), sum(y), &
355 &                       sum(x),   sum(y),   REAL(N, RK8) /), shape=(/ 3, 3 /))
356 
357 b = (/ sum(x*z), sum(y*z), sum(z) /)
358 
359 !
360 ! These calls solve the matrix equation AX=B\&. First, we calculate the LU decomposition of A using the LUDCMP
361 ! subroutine, then we solve for X using the LUBKSB subroutine\&. Details on the maths behind all this can be found
362 ! from many sources\&.
363 !
364 CALL ludcmp(a, 3, indx, d, code)
365 IF (code \&.EQ\&. 1) THEN
366     print *,'W: Tried to do a LU decomposition on a singular matrix\&.'
367     print *,'   This code is not clever enough to handle this case\&.'
368     stop '1'
369 END IF
370 CALL lubksb(a, 3, indx, b)
371 
372 dzdx = b(1)
373 dzdy = b(2)
374 z0   = b(3)
375 
.fi
.SS "subroutine numerics::smooth (real (kind=rk8), dimension(n), intent(inout) ARRAY, integer (kind=ik4), intent(in) N, integer (kind=ik4), intent(in) FILTER_WIDTH, logical, intent(in) CYCLIC)"

.PP
Definition at line 90 of file numerics\&.f90\&.
.PP
.nf
90 USE portable
91 
92 IMPLICIT NONE
93 INTEGER (KIND=IK4), INTENT(IN)                      :: n            ! Number of elements in ARRAY\&.
94 INTEGER (KIND=IK4), INTENT(IN)                      :: filter_width ! Width of the box car filter\&.
95 REAL (KIND=RK8), DIMENSION(N), INTENT(INOUT)        :: array        ! The array of data being filtered\&.
96 LOGICAL, INTENT(IN)                                 :: cyclic       ! Set to \&.TRUE\&. if data are cyclic\&.
97 
98 !
99 ! Local variables\&.
100 !
101 REAL (KIND=RK8), DIMENSION(:), ALLOCATABLE          :: tmparray1,tmparray2     ! Temporary array used for filtering\&.
102 INTEGER (KIND=IK4)                                  :: tmpwidth     ! Filter width\&.
103 INTEGER (KIND=IK4)                                  :: memst        ! Status code from memory allocation functions\&.
104 INTEGER (KIND=IK4)                                  :: ii           ! Counter\&.
105 
106 !
107 ! First check that (i) the filter width is not too large, and (ii) the filter width is an odd number\&. If the filter width is an even
108 ! number, we set a temporary filter width which is one greater than the value passed to the subroutine\&.
109 !
110 IF (mod(filter_width, 2) \&.EQ\&. 0) THEN
111     tmpwidth    = filter_width + 1
112 ELSE
113     tmpwidth    = filter_width
114 END IF
115 
116 IF (tmpwidth \&.GT\&. n) THEN
117     print *,'W: Setting filter width to be the same as the number of points in array, ',n
118     tmpwidth    = n
119 END IF
120 
121 
122 !
123 ! Allocate a temporary array to be used with filtering\&. If the data are cyclic, then this array is slightly larger, to allow
124 ! us to nicely handle data at the beginning and ends of the array\&.
125 !
126 IF (cyclic) THEN
127     ALLOCATE(tmparray1(n+tmpwidth-1), tmparray2(n+tmpwidth-1), stat=memst)
128     IF (memst \&.NE\&. 0) THEN
129         print *,'Not able to allocate memory for the temporary filtering array'
130         stop '1'
131     END IF
132     tmparray1(1:tmpwidth/2)                  = array(n-tmpwidth/2+1:n)   ! I think this still works when TMPWIDTH/2 = 0
133     tmparray1(tmpwidth/2+1:tmpwidth/2+n)     = array(1:n)
134     tmparray1(tmpwidth/2+n+1:tmpwidth+n-1)   = array(1:tmpwidth/2)
135 ELSE
136     ALLOCATE(tmparray1(n), tmparray2(n), stat=memst)
137     IF (memst \&.NE\&. 0) THEN
138         print *,'Not able to allocate memory for the temporary filtering array'
139         stop '1'
140     END IF
141     tmparray1    = array
142 END IF
143 
144 !
145 ! Now do the box car filtering\&.
146 !
147 DO ii=1,SIZE(tmparray2)
148         tmparray2(ii)   = sum(tmparray1(max(1, ii-tmpwidth/2):min(ii+tmpwidth/2, SIZE(tmparray2))))/tmpwidth
149 END DO
150 
151 array(1:n)  = tmparray2(tmpwidth/2+1:tmpwidth/2+n)
152 
153 !
154 ! Deallocate allocated memory\&.
155 !
156 IF (ALLOCATED(tmparray1))    DEALLOCATE(tmparray1)
157 IF (ALLOCATED(tmparray2))    DEALLOCATE(tmparray2)
158 
.fi
.SS "subroutine numerics::windown (integer (kind=ik4), intent(in) N, real (kind=rk8), dimension(n), intent(in) X, real(kind=rk8), intent(in) DX, real (kind=rk8), intent(in) X1, integer (kind=ik4), intent(in) L0, integer (kind=ik4), intent(out) L1)"

.PP
Definition at line 389 of file numerics\&.f90\&.
.PP
.nf
389 USE portable
390 
391 IMPLICIT NONE
392 INTEGER (KIND=IK4), INTENT(IN)                  :: n        ! Number of vertical layers\&.
393 REAL (KIND=RK8), DIMENSION(N), INTENT(IN)       :: x        ! Array containing the levels of each layer\&.
394 REAL(KIND=RK8), INTENT(IN)                      :: dx       ! Layer depth (assume layers are equal depth)\&.
395 REAL (KIND=RK8), INTENT(IN)                     :: x1       ! We are searching for the layer which includes this level\&.
396 INTEGER (KIND=IK4), INTENT(IN)                  :: l0       ! The bottom layer to start searching at\&.
397 INTEGER (KIND=IK4), INTENT(OUT)                 :: l1       ! The index of the layer which contains the X1 level\&.
398 
399 !
400 ! Local variables\&.
401 !
402 REAL (KIND=RK8)                                 :: xa, xb   ! Top and bottom of the vertical layer\&.
403 INTEGER (KIND=IK4)                              :: ll       ! Layer number\&.
404 
405 l1      = -1
406 ll      = l0
407 DO WHILE ((ll \&.LE\&. n) \&.AND\&. (l1 \&.EQ\&. -1))
408     xa  = x(ll) - dx*(0\&.5+0\&.1)
409     xb  = x(ll) + dx*(0\&.5-0\&.1)
410     IF ((x1 \&.GE\&. xa) \&.AND\&. (x1 \&.LT\&. xb)) l1 = ll
411     ll  = ll + 1
412 END DO
413 
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Variational Analysis from the source code\&.
